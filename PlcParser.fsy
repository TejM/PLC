%{
 open Absyn
 open ParAux
%}

%token <int> CSTINT
%token <string> NAME
%token <bool> CSTBOOL

/*      Nil  Bool  Int   ->     */
%token  NIL  BOOL  INT  ARROW

/*      =>      fn  end  */
%token  DARROW  FN  END

/*      var  fun  rec  */
%token  VAR  FUN  REC

/*      if  then  else  */
%token  IF  THEN  ELSE

/*      match  with  |     _          */
%token  MATCH  WITH  PIPE  UNDERSCORE

/*      !    &&   */
%token  NOT  AND

/*      ::    hd    tl    ise  */
%token  CONS  HEAD  TAIL  ISE

/*      print  */
%token  PRINT

/*      +     -      *      /     */
%token  PLUS  MINUS  TIMES  DIV

/*      =   !=   <   <=   */
%token  EQ  NEQ  LT  LTE

/*      (     )     {       }       [       ]       */
%token  LPAR  RPAR  LBRACE  RBRACE  LBRACK  RBRACK

/*      ,      :      ;      */
%token  COMMA  COLON  SEMIC

%token EOF


%right SEMIC ARROW
%nonassoc IF MATCH
%left ELSE
%left AND
%left EQ NEQ
%left LT LTE
%right CONS
%left PLUS MINUS
%left TIMES DIV
%nonassoc NOT HEAD TAIL ISE PRINT NAME
%left LBRACK

%start Main
%type <Absyn.expr> Main

%%

/*  Add production rules below */

Prog :
    Expr 
  | Decl SEMIC Prog
;

Decl :
    VAR NAME EQ Expr
  | FUN NAME Args EQ Expr
  | FUN REC NAME Args COLON Type EQ Expr
;

Expr :
    AtomicExpr                                       atomic expression
  | AppExpr                                          function application
  | IF Expr THEN Expr ELSE Expr                      conditional expression
  | MATCH Expr WITH MatchExpr                        match expression
  | NOT Expr                     { Prim1("!", $2) }                    unary operator application
  | MINUS Expr                   { Prim1("-", $2) }
  | HEAD Expr
  | TAIL Expr
  | ISE Expr
  | PRINT Expr
  | Expr PLUS Expr               { Prim2("+", $1, $3) }                   binary operator application
  | Expr MINUS Expr              { Prim2("-", $1, $3) }
  | Expr TIMES Expr              { Prim2("*", $1, $3) }
  | Expr DIV Expr                { Prim2("/", $1, $3) }
  | Expr EQ Expr                 { Prim2("=", $1, $3) }
  | Expr NEQ Expr                { Prim2("!=", $1, $3) }
  | Expr LT Expr                 { Prim2("<", $1, $3) }
  | Expr LTE Expr                { Prim2("<=", $1, $3) }
  | Expr CONS Expr
  | Expr SEMIC Expr
  | Expr LBRACK Const RBRACK                         Const is Nat might need to add case for that
;

AtomicExpr :
    Const                               {    }       constant literal
  | NAME                                {    }       function, variable or parameter name
  | LBRACK Prog RBRACK                  {    }       local scope block
  | LPAR Expr RPAR                      {    }       parenthesized expression
  | LPAR Comps RPAR                     {    }       list
  | FN Args DARROW Expr END             {    }       anonymous function
;

AppExpr :                                            function application
    AtomicExpr AtomicExpr               {    }
  | AppExpr AtomicExpr                  {    }
;

Const :
    CSTBOOL                             {    }           combined true and false which I think is fine
  | CSTINT                              {    }           numerals NAT? need to add NAT to parser or is it CSTINT?
  | LPAR RPAR                           { [] }           unit value
  | LPAR Type LBRACK RBRACK RPAR        {    }           type-annotated empty sequence
;

Comps :                                       list components
    Expr COMMA Expr         { [$1; $3] }
  | Expr COMMA Comps        { $1 :: $3 }
;

MatchExpr :                                   match cases
    END 
  | PIPE CondExpr ARROW Expr MatchExpr
;

CondExpr :                                    values to be matched against
    EXPR
  | UNDERSCORE
;

Args:                                         function arguments
    LPAR RPAR                { []       }
  | Arg                      { [$1]     }
  | Arg COMMA Args           { $1 :: $3 }
  | LPAR Arg COMMA Args RPAR { $2 :: $4 }
  | LPAR Arg RPAR            { [$2]     }
;

Arg:
    Type NAME { $1, $2 }
;

Type :
    AtomicType
  | LPAR Types RPAR                           list type
  | LBRACK Type RBRACK                        sequence type
  | Type ARROW Type                           function type
;

AtomicType :
    NIL                                       Nil type
  | BOOL                                      Boolean type
  | INT                                       integer type
  | LPAR Type RPAR
;

Types :
    Type COMMA Type
  | Type COMMA Types;